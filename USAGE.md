# Руководство по использованию SQL Query Optimizer

## Обзор

SQL Query Optimizer - это консольная утилита для оптимизации и разбиения SQL запросов с использованием Apache Calcite. Утилита использует cost-based оптимизацию для анализа стоимости выполнения запросов и разбивает сложные запросы на более мелкие подзапросы.

## Основные возможности

- **Cost-based оптимизация**: Использует Apache Calcite для анализа стоимости выполнения
- **Разбиение запросов**: Автоматически разбивает запросы на основе порога стоимости
- **Временные таблицы**: Создает временные таблицы для промежуточных результатов
- **Анализ метаданных**: Работает с метаданными хранилища в JSON формате
- **Статистика**: Учитывает статистику таблиц для точной оценки стоимости

## Установка и сборка

### Требования
- Java 11 или выше
- Maven 3.6 или выше

### Сборка
```bash
mvn clean package
```

После сборки создается исполняемый JAR файл: `target/sql-query-optimizer-1.0.0.jar`

## Использование

### Базовый синтаксис
```bash
java -jar target/sql-query-optimizer-1.0.0.jar [опции]
```

### Параметры командной строки

| Параметр | Краткая форма | Описание | Обязательный |
|----------|---------------|----------|--------------|
| `--sql` | `-s` | SQL запрос для оптимизации | Да* |
| `--sql-file` | `-f` | Файл с SQL запросом | Да* |
| `--metadata` | `-m` | Файл с метаданными хранилища (JSON) | Да |
| `--statistics` | `-t` | Файл со статистикой таблиц (JSON) | Нет |
| `--output` | `-o` | Файл для сохранения результата (JSON) | Нет |
| `--threshold` | `-c` | Порог стоимости для разбиения (по умолчанию: 1000.0) | Нет |
| `--help` | `-h` | Показать справку | Нет |

*Необходимо указать либо `--sql`, либо `--sql-file`

### Примеры использования

#### 1. Простой запрос
```bash
java -jar target/sql-query-optimizer-1.0.0.jar \
  --sql "SELECT * FROM employees WHERE salary > 50000" \
  --metadata metadata.json
```

#### 2. Запрос из файла с сохранением результата
```bash
java -jar target/sql-query-optimizer-1.0.0.jar \
  --sql-file query.sql \
  --metadata metadata.json \
  --statistics statistics.json \
  --threshold 500 \
  --output result.json
```

#### 3. Запрос с низким порогом стоимости
```bash
java -jar target/sql-query-optimizer-1.0.0.jar \
  --sql "SELECT e.name, d.name FROM employees e JOIN departments d ON e.department_id = d.id" \
  --metadata metadata.json \
  --threshold 100
```

## Форматы файлов

### Метаданные (metadata.json)

```json
{
  "tables": [
    {
      "name": "employees",
      "columns": [
        {"name": "id", "type": "integer"},
        {"name": "name", "type": "varchar"},
        {"name": "department_id", "type": "integer"},
        {"name": "salary", "type": "decimal"},
        {"name": "hire_date", "type": "date"}
      ]
    },
    {
      "name": "departments",
      "columns": [
        {"name": "id", "type": "integer"},
        {"name": "name", "type": "varchar"},
        {"name": "location", "type": "varchar"}
      ]
    }
  ],
  "views": [
    {
      "name": "employee_summary",
      "sql": "SELECT e.id, e.name, d.name as department_name FROM employees e JOIN departments d ON e.department_id = d.id"
    }
  ]
}
```

### Статистика (statistics.json)

```json
{
  "tables": [
    {
      "name": "employees",
      "rowCount": 1000,
      "columnStats": [
        {"name": "id", "distinctValues": 1000, "nullCount": 0},
        {"name": "name", "distinctValues": 950, "nullCount": 0},
        {"name": "department_id", "distinctValues": 10, "nullCount": 0},
        {"name": "salary", "distinctValues": 500, "nullCount": 0}
      ]
    }
  ]
}
```

### Результат оптимизации

```json
{
  "originalQuery": "SELECT e.name, d.name FROM employees e JOIN departments d ON e.department_id = d.id",
  "subQueries": [
    {
      "id": "Q1",
      "sql": "SELECT * FROM (rel#0:LogicalTableScan.NONE.[](table=[employees]))",
      "cost": 100.0,
      "dependencies": [],
      "isTemporaryTable": false,
      "temporaryTableName": null,
      "description": "Подзапрос Q1 со стоимостью 100.0"
    }
  ],
  "totalCost": 100.0,
  "optimizationPlan": "=== ПЛАН ОПТИМИЗАЦИИ ===\n...",
  "success": true,
  "errorMessage": null
}
```

## Алгоритм работы

1. **Парсинг метаданных**: Создание схемы Calcite на основе метаданных
2. **Загрузка статистики**: Применение статистики таблиц (если предоставлена)
3. **Парсинг SQL**: Преобразование SQL запроса в дерево операций Calcite
4. **Оптимизация**: Применение cost-based оптимизации
5. **Разбиение**: Анализ стоимости узлов и разбиение на подзапросы
6. **Генерация результата**: Создание плана выполнения

## Критерии разбиения

Утилита использует метод `getCumulativeCost` класса `RelMetadataQuery` Apache Calcite для вычисления стоимости выполнения каждого узла запроса. Запрос разбивается на подзапросы, если:

- Стоимость узла превышает установленный порог
- Узел можно разбить (JOIN, Project, Filter, Aggregate)
- Разбиение не нарушает семантику запроса

## Временные таблицы

При разбиении запроса утилита может создавать временные таблицы для хранения промежуточных результатов:

- Позволяет выполнять подзапросы последовательно
- Переиспользовать результаты между подзапросами
- Уменьшить нагрузку на основное хранилище

## Логирование

Утилита использует SLF4J для логирования. Уровень логирования можно настроить:

```bash
java -Dorg.slf4j.simpleLogger.defaultLogLevel=DEBUG \
  -jar target/sql-query-optimizer-1.0.0.jar \
  --sql "SELECT * FROM employees" \
  --metadata metadata.json
```

## Обработка ошибок

Утилита обрабатывает различные типы ошибок:

- **Ошибки парсинга SQL**: Некорректный синтаксис запроса
- **Ошибки метаданных**: Неверный формат или отсутствующие таблицы
- **Ошибки оптимизации**: Проблемы с Calcite оптимизатором
- **Ошибки файлов**: Отсутствующие или недоступные файлы

При возникновении ошибки утилита возвращает JSON с полем `success: false` и описанием ошибки в поле `errorMessage`.

## Примеры сценариев

### Сценарий 1: Оптимизация простого запроса
```bash
# Входные данные
SQL: SELECT * FROM employees WHERE salary > 50000
Порог: 1000

# Результат
- 1 подзапрос
- Стоимость: 100.0
- Без временных таблиц
```

### Сценарий 2: Оптимизация сложного запроса
```bash
# Входные данные
SQL: Сложный JOIN с агрегацией
Порог: 500

# Результат
- Несколько подзапросов
- Временные таблицы для промежуточных результатов
- Последовательное выполнение
```

### Сценарий 3: Запрос с низким порогом
```bash
# Входные данные
SQL: Простой запрос
Порог: 50

# Результат
- Множественные подзапросы
- Максимальное разбиение
- Оптимальное использование ресурсов
```

## Советы по использованию

1. **Выбор порога стоимости**: Начните с высокого порога (1000+) и уменьшайте по необходимости
2. **Метаданные**: Убедитесь, что все таблицы и колонки описаны корректно
3. **Статистика**: Предоставляйте актуальную статистику для лучшей оптимизации
4. **Тестирование**: Тестируйте на небольших запросах перед применением к сложным
5. **Мониторинг**: Анализируйте логи для понимания процесса оптимизации

## Ограничения

- Текущая версия использует упрощенную логику оптимизации
- Поддерживаются основные SQL операции (SELECT, JOIN, WHERE, GROUP BY)
- Ограниченная поддержка сложных агрегаций
- Требует корректных метаданных для работы

## Планы развития

- Полная интеграция с Apache Calcite оптимизатором
- Поддержка более сложных SQL конструкций
- Интеграция с различными СУБД
- Веб-интерфейс для визуализации планов
- API для программного использования




